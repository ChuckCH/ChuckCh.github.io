---
layout: post
title:  "Redis深度历险:核心原理和应用实践"
categories: jekyll update
---

<a href="https://zhuanlan.zhihu.com/p/32540678" target="_blank">天下无难试</a>

5种数据结构 string、list、set、hash、zset

**string** 类似ArrayList，预分配内存，小于1M扩容加倍，一次扩容最多1M，字符串最大长度512M

**list** 类似LinkedList，插入删除O(1)，索引定位O(n)，常做异步队列，将任务塞进list，另一线程轮询

**慢操作** lindex 性能随index变大而增差 ltrim同理，

redis底层用的quicklist，元素较少时 ziplist，连续内存，元素较多时，用quicklist将多个ziplist用双向指针串起来。

**hash** 类似HashMap 数组+链表 为了性能采用渐进式rehash 

**set** 类似HashSet

**zset** 类似SortedSet+HashMap 跳跃列表 层级制，每隔几个元素挑出代表，随即策略决定新元素可以到达第几层

![](D:\Users\hangchen\blog\images\屏幕截图_20211108170333.png)

通用规则 create if not exists；drop if no elements

分布式锁 一般适用setnx（set if not exusts）用完了再del  如果执行出现异常，可能会导致无法调用del 进而死锁，所以一般需加上过期时间。但setnx 和expire不是原子操作，还是会出现问题。Redis 2.8 修复了这一问题，set lock true ex 5 nx

> - `EX seconds` − 设置指定的到期时间(以秒为单位)。
> - `PX milliseconds` - 设置指定的到期时间(以毫秒为单位)。
> - `NX` - 仅在键不存在时设置键。
> - `XX` - 只有在键已存在时才设置。

如果任务时间大于锁过期时间，那么第一个任务的释放锁操作释放了第二个任务的锁，第三个任务会提前拿到锁。会导致超时问题。

**可重入性**  如果一个锁支持同一线程多次加速，那么就是可重入的， Redis如果需要支持可重入 ，需对set进行包装，使用线程ThreadLocal变量存储当前锁的计数。

